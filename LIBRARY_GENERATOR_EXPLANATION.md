# Library Generator Feature - Detailed Explanation

## Overview

The Admin SQL Migration Generator allows administrators to design custom libraries through a UI, which generates complete SQL migration files and optional React components.

## User Flow

### Step 1: Define Library Properties

**Form Fields:**

- **Library Name**: "Equipment Spares"
- **Table Name**: `equipment_spares_library` (auto-generated, sanitized)
- **Description**: "Store spare parts and replacement components for equipment"
- **Icon/Color**: Visual identifier for the library

### Step 2: Define Fields

**Dynamic Field Builder:**
Each field includes:

- **Field Name**: "Part Number"
- **Database Column**: `part_number` (auto-generated)
- **Data Type**: TEXT, NUMERIC, INTEGER, BOOLEAN, DATE, TIMESTAMP
- **Required**: Yes/No
- **Default Value**: (optional)
- **Display in Main Table**: Yes/No (for table columns)
- **Category Options**: (optional) for dropdown fields
- **Validation Rules**: min/max, regex patterns

**Example Fields:**

```
1. Part Number (TEXT, Required, Main Table)
2. Description (TEXT, Required, Main Table)
3. Equipment Type (TEXT, Category: ['Motor', 'Pump', 'Valve', 'Sensor'])
4. Quantity in Stock (INTEGER, Default: 0, Main Table)
5. Unit Cost (NUMERIC, Required)
6. Supplier (TEXT)
7. Reorder Level (INTEGER, Default: 5)
8. Location (TEXT, Required)
9. Notes (TEXT)
```

### Step 3: Advanced Settings

- **RLS Policies**: Auto-generate standard company-scoped policies
- **Indexes**: Auto-generate indexes on company_id, name fields
- **Triggers**: Auto-generate updated_at trigger
- **Categories**: Define category dropdown options
- **Main Table Columns**: Select which fields show in table view
- **CSV Import/Export**: Enable/disable

### Step 4: Generate SQL

**Output Files Generated:**

1. **Migration SQL** (`create_[table_name].sql`):

```sql
-- ============================================
-- Create equipment_spares_library Table
-- ============================================
-- Generated by Library Generator on 2025-01-27

DROP TABLE IF EXISTS equipment_spares_library CASCADE;

CREATE TABLE equipment_spares_library (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
  part_number TEXT NOT NULL,
  description TEXT NOT NULL,
  equipment_type TEXT,
  quantity_in_stock INTEGER DEFAULT 0,
  unit_cost NUMERIC(10, 2),
  supplier TEXT,
  reorder_level INTEGER DEFAULT 5,
  location TEXT NOT NULL,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT equipment_spares_library_part_number_check
    CHECK (part_number IS NOT NULL AND part_number != '')
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_equipment_spares_company_id
  ON equipment_spares_library(company_id);
CREATE INDEX IF NOT EXISTS idx_equipment_spares_part_number
  ON equipment_spares_library(part_number);
CREATE INDEX IF NOT EXISTS idx_equipment_spares_equipment_type
  ON equipment_spares_library(equipment_type);

-- Updated_at Trigger
CREATE OR REPLACE FUNCTION update_equipment_spares_library_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_equipment_spares_library_updated_at
  BEFORE UPDATE ON equipment_spares_library
  FOR EACH ROW
  EXECUTE FUNCTION update_equipment_spares_library_updated_at();

-- RLS Policies
ALTER TABLE equipment_spares_library ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view equipment spares from their own company"
  ON equipment_spares_library FOR SELECT
  USING (company_id IN (SELECT company_id FROM profiles WHERE id = auth.uid()));

CREATE POLICY "Users can create equipment spares for their own company"
  ON equipment_spares_library FOR INSERT
  WITH CHECK (company_id IN (SELECT company_id FROM profiles WHERE id = auth.uid()));

CREATE POLICY "Users can update equipment spares from their own company"
  ON equipment_spares_library FOR UPDATE
  USING (company_id IN (SELECT company_id FROM profiles WHERE id = auth.uid()));

CREATE POLICY "Users can delete equipment spares from their own company"
  ON equipment_spares_library FOR DELETE
  USING (company_id IN (SELECT company_id FROM profiles WHERE id = auth.uid()));

-- Permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON equipment_spares_library TO authenticated;
```

2. **RLS Update Script** (if updating existing):
   - Same pattern as other libraries
   - Uses DROP POLICY IF EXISTS for idempotency

3. **TypeScript Types** (optional):

```typescript
export interface EquipmentSparesLibrary {
  id: string;
  company_id: string;
  part_number: string;
  description: string;
  equipment_type: string | null;
  quantity_in_stock: number | null;
  unit_cost: number | null;
  supplier: string | null;
  reorder_level: number | null;
  location: string;
  notes: string | null;
  created_at: string;
  updated_at: string;
}
```

4. **React Component Template** (optional):
   - Pre-built page component with inline editing
   - CSV import/export
   - Search and filter
   - RLS-safe operations

### Step 5: Review & Download

**Preview Panel:**

- Syntax-highlighted SQL preview
- Validation warnings/errors
- Estimated execution time
- Component preview (if generated)

**Download Options:**

- Download SQL migration file
- Download TypeScript types
- Download React component
- Copy to clipboard

### Step 6: Manual Deployment

**Instructions Provided:**

1. Open Supabase SQL Editor
2. Copy and paste the SQL
3. Review carefully
4. Execute
5. Verify table creation
6. (Optional) Add the generated component to your routes

## Implementation Details

### Field Type Mapping

| UI Type   | PostgreSQL Type | Validation                   |
| --------- | --------------- | ---------------------------- |
| Text      | TEXT            | Length constraints, NOT NULL |
| Number    | NUMERIC(10,2)   | Min/max, NOT NULL            |
| Integer   | INTEGER         | Min/max, NOT NULL            |
| Boolean   | BOOLEAN         | Default true/false           |
| Date      | DATE            | Date validation              |
| Timestamp | TIMESTAMPTZ     | Auto-now options             |
| Category  | TEXT with CHECK | Dropdown values              |
| Text Area | TEXT            | Max length                   |

### Safety Features

1. **SQL Injection Prevention**:
   - Sanitize all user inputs
   - Parameterize where possible
   - Escape identifiers properly

2. **Validation**:
   - Table name format validation
   - Field name sanitization
   - No reserved keywords
   - Type safety checks

3. **Idempotency**:
   - All migrations use IF EXISTS/IF NOT EXISTS
   - Safe to run multiple times

4. **Review Required**:
   - SQL is never auto-executed
   - Admin must manually run in Supabase
   - Prevents accidental schema changes

### Advanced Features (Future)

1. **Field Relationships**:
   - Foreign keys to other libraries
   - Reference constraints

2. **Custom Validations**:
   - Regex patterns
   - Conditional requirements
   - Cross-field validation

3. **Migration Versioning**:
   - Track generated migrations
   - Rollback capabilities
   - Version control integration

4. **Template Library**:
   - Save common field patterns
   - Reuse across libraries
   - Community templates

## Example Use Cases

### Use Case 1: Equipment Spares Library

- **Purpose**: Track spare parts inventory
- **Fields**: Part number, description, quantity, cost, supplier, location
- **Benefits**: Inventory management, reorder tracking

### Use Case 2: Training Materials Library

- **Purpose**: Store training resources
- **Fields**: Title, category, format (video/pdf), duration, certification type
- **Benefits**: Training program management

### Use Case 3: Supplier Directory

- **Purpose**: Manage supplier information
- **Fields**: Company name, contact, specialties, certification status, rating
- **Benefits**: Vendor relationship management

## Security Considerations

1. **Permission Check**:
   - Only users with admin role can access generator
   - Company-scoped where applicable

2. **SQL Review**:
   - All SQL visible before execution
   - No hidden operations
   - Audit log of generated migrations

3. **Limitations**:
   - Cannot modify existing libraries (safety)
   - Cannot access system tables
   - Cannot execute arbitrary SQL

## Benefits

✅ **Flexibility**: Create unlimited custom libraries
✅ **Safety**: Review before deployment
✅ **Speed**: Generate complete migrations in minutes
✅ **Consistency**: Follows same patterns as existing libraries
✅ **Quality**: Includes RLS, indexes, triggers automatically
✅ **Maintainability**: Standardized structure

## Limitations

⚠️ **Manual Step**: Requires SQL execution in Supabase
⚠️ **No Auto-Deploy**: Cannot automatically modify database
⚠️ **Learning Curve**: Admin needs basic SQL understanding
⚠️ **Type Generation**: TypeScript types need manual integration

## Conclusion

This approach gives maximum flexibility while maintaining safety and control. Admins can create custom libraries quickly, but deployment requires manual review, preventing accidental schema changes.
