# Project Context & Guidelines for AI Assistants

## Project Overview
This is a Next.js 15 web application for managing health & safety, food safety, and operational compliance for hospitality venues. Built with TypeScript, Supabase, and modern React patterns.

**Multi-Module Architecture:**
The application consists of three interchangeable modules:
- **Checkly**: Health & safety, food safety, compliance, and task management
- **Stockly**: Inventory, stock management, and purchasing
- **Teamly**: HR, people management, scheduling, payroll, and attendance

These modules can be:
- Used **standalone** (each module works independently)
- **Bundled together** (all three in one installation)
- **Bolted on** (modules added to existing installations)

**CRITICAL:** All modules MUST share compatible database schemas to ensure interoperability.

## Tech Stack
- **Framework**: Next.js 15 (App Router)
- **Language**: TypeScript
- **Database**: Supabase (PostgreSQL)
- **Styling**: Tailwind CSS
- **UI Components**: shadcn/ui
- **State Management**: React Context (AppContext)
- **Auth**: Supabase Auth

## Project Structure
```
/src
  /app                    # Next.js App Router pages
    /dashboard           # Dashboard routes
    /organization        # Legacy redirects to /dashboard/*
  /components            # React components
    /ui                  # shadcn/ui components (Button, Input, etc.)
    /layouts             # Layout components (NewMainSidebar, etc.)
    /dashboard           # Dashboard-specific components
  /lib                   # Utilities and helpers
    /supabase.ts         # Client-side Supabase client
    /supabase-server.ts  # Server-side Supabase client
  /context               # React Context providers (AppContext, SOPContext)
  /types                 # TypeScript type definitions
  /hooks                 # Custom React hooks
/public                  # Static assets
  /assets                # Images and SVGs
```

## Key Architecture Decisions

### 1. Next.js App Router
- Use Server Components by default
- Mark components with `'use client'` only when needed (hooks, event handlers, browser APIs)
- Leverage Server Actions for data mutations when appropriate

### 2. Supabase Patterns
**Client-side (browser):**
```typescript
import { supabase } from '@/lib/supabase';
// Uses createBrowserClient internally, singleton instance
```

**Server-side (API routes, Server Components):**
```typescript
import { createServerSupabaseClient } from '@/lib/supabase-server';
const supabase = await createServerSupabaseClient();
```

- Always handle errors gracefully
- Use TypeScript types from `@/types/supabase`
- The `supabase` export from `@/lib/supabase` is a singleton browser client

### 3. Component Patterns
- Prefer composition over prop drilling
- Use shadcn/ui components as building blocks
- Keep components focused and single-responsibility
- Extract reusable logic into custom hooks

### 4. Styling Conventions
- Use Tailwind utility classes
- Follow mobile-first responsive design
- Maintain consistent spacing scale (4, 8, 16, 24, 32px)
- Use design tokens from Tailwind config
- Background: `bg-[#0B0D13]` for main app background
- Borders: `border-white/[0.06]` for card borders
- Cards: `bg-white/[0.03]` with `border border-white/[0.06]`

### 5. Dropdown/Select Menu Styling
**REQUIRED:** All dropdown menus (`<select>` elements) MUST have:
- Light text on dark backgrounds: `text-white` or `text-gray-100`
- Dark background: `bg-white/[0.03]` or `bg-[#0B0D13]` or similar dark background
- Proper contrast for readability
- Option elements should also use dark backgrounds where possible (browser limitations apply)
- Use the global CSS select styling in `globals.css` as a base
- Example: `className="w-full px-4 py-2 bg-white/[0.03] border border-white/[0.06] rounded-md text-white focus:outline-none focus:ring-2 focus:ring-[#EC4899]/50"`

### 6. Button UX Language
**Standard Button Style:**
- Background: `bg-transparent`
- Text: `text-[#EC4899]` (magenta, NOT pink)
- Border: `border border-[#EC4899]` (magenta)
- Hover: `hover:shadow-[0_0_12px_rgba(236,72,153,0.7)]` (magenta glow)
- Transition: `transition-all duration-200 ease-in-out`

**DO NOT USE:** Pink backgrounds (`bg-pink-500`) or solid pink buttons. All accent buttons should use magenta text with magenta border and glow on hover.

### 6.5. STOCKLY MODULE STYLING

Stockly (production/wholesale module) uses a distinct emerald theme to differentiate from Checkly's magenta:

**Colors:**
- Primary: Emerald (#10B981, emerald-500)
- Primary hover: #059669 (emerald-600)
- Accents: #34D399 (emerald-400)
- Dark accents: #047857 (emerald-700)

**Component Examples:**
```tsx
// Buttons
<button className="bg-emerald-500 hover:bg-emerald-600 text-white">
  Save
</button>

// Badges
<span className="bg-emerald-500/10 text-emerald-500 border border-emerald-500/20">
  Active
</span>

// Cards
<div className="bg-white/[0.03] border border-white/[0.06]">
  {/* content */}
</div>

// Links
<a className="text-emerald-400 hover:text-emerald-300">
  View Details
</a>

// Focus states
<input className="focus:ring-2 focus:ring-emerald-500/50" />
```

**Status Colors:**
- Success: Emerald (bg-emerald-500/10, text-emerald-500)
- Warning: Amber (bg-amber-500/10, text-amber-500)
- Error: Red (bg-red-500/10, text-red-500)
- Info: Blue (bg-blue-500/10, text-blue-500)

**Navigation:**
Stockly pages under `/dashboard/stockly` should use emerald highlights in navigation

**Consistency:**
- All Stockly components, badges, buttons, and interactive elements use emerald theme
- All Checkly/Teamly components continue using magenta theme (#EC4899)

### 7. Multi-Module Schema Compatibility
**CRITICAL:** Checkly, Stockly, and Teamly are designed to work as:
- **Standalone modules** (each can be used independently)
- **Bundled together** (all three modules in one installation)
- **Bolt-on modules** (modules can be added to existing installations)

**Schema Design Requirements:**
1. **Shared Core Tables**: All modules MUST use the same core table names and column names:
   - `companies` - Company/organization data
   - `sites` - Site/location data
   - `profiles` - User profiles (NOT `users`, NOT `employees`)
   - `user_roles` - Role assignments (use `profile_id`, NOT `user_id`)
   - `roles` - Role definitions
   - `permissions` - Permission definitions
   - `departments` - Department structure
   - `areas` / `company_areas` - Area definitions
   - `regions` / `company_regions` - Region definitions

2. **Consistent Column Names**: 
   - User references: Always use `profile_id` (references `profiles.id`), NEVER `user_id` or `employee_id`
   - Company references: Always use `company_id` (references `companies.id`)
   - Site references: Always use `site_id` (references `sites.id`)
   - Timestamps: Use `created_at`, `updated_at` (not `created`, `modified`, etc.)

3. **Foreign Key Compatibility**:
   - Before creating foreign keys, check if referenced tables exist
   - Use conditional FK creation: `IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'table_name')`
   - Handle both `areas`/`company_areas` and `regions`/`company_regions` naming variations

4. **Migration Safety**:
   - All migrations MUST be idempotent (can run multiple times safely)
   - Use `CREATE TABLE IF NOT EXISTS` or `DO $$` blocks to check existence
   - Use `DROP TABLE IF EXISTS` / `DROP INDEX IF EXISTS` / `DROP POLICY IF EXISTS` before creating
   - Check for existing columns before adding: `IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE...)`

5. **Table Naming Conflicts**:
   - Before creating a table, check if it exists with a different schema
   - If an incompatible table exists (e.g., old `user_roles` with `user_id`), drop and recreate
   - Document schema migrations in migration comments

6. **Module-Specific Tables**: 
   - Use clear prefixes for module-specific tables (e.g., `teamly_shift_rules`, `stockly_stock_levels`, `checkly_tasks`)
   - Shared tables should NOT have module prefixes

**Example - Safe Table Creation:**
```sql
-- ✅ Good: Handles existing incompatible schema
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_schema = 'public' AND table_name = 'user_roles'
    AND EXISTS (
      SELECT 1 FROM information_schema.columns 
      WHERE table_name = 'user_roles' AND column_name = 'user_id'
    )
  ) THEN
    DROP TABLE IF EXISTS user_roles CASCADE;
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.tables 
    WHERE table_schema = 'public' AND table_name = 'user_roles'
  ) THEN
    CREATE TABLE user_roles (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      profile_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
      -- ... rest of schema
    );
  END IF;
END $$;
```

**Before Creating Any Table/Column:**
1. Check if table/column already exists
2. Check if it has compatible schema
3. If incompatible, drop and recreate (or migrate data if needed)
4. Always use `profile_id` for user references, never `user_id` or `employee_id`

## Code Style Guidelines

### TypeScript
```typescript
// ✅ Good: Explicit types for function parameters and returns
export async function fetchTasks(userId: string): Promise<Task[]> {
  // implementation
}

// ✅ Good: Interface for complex objects
interface TaskFormData {
  title: string;
  description: string;
  dueDate: Date;
}

// ❌ Avoid: Using 'any'
const data: any = await fetchData(); // Don't do this
```

### React Components
```typescript
// ✅ Good: Named exports for components
export function TaskCard({ task }: { task: Task }) {
  return <div>{task.title}</div>;
}

// ✅ Good: Separate client/server concerns
'use client';
export function InteractiveButton() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

### Async Operations
```typescript
// ✅ Good: Proper error handling
try {
  const { data, error } = await supabase.from('tasks').select('*');
  if (error) throw error;
  return data;
} catch (error) {
  console.error('Failed to fetch tasks:', error);
  return null;
}

// ❌ Avoid: Ignoring errors
const { data } = await supabase.from('tasks').select('*'); // No error handling
```

## Common Patterns in This Project

### 1. Fetching Data (Client Component)
```typescript
'use client';
import { supabase } from '@/lib/supabase';

export default function TasksPage() {
  const [tasks, setTasks] = useState([]);
  
  useEffect(() => {
    async function loadTasks() {
      const { data, error } = await supabase.from('tasks').select('*');
      if (error) console.error('Error:', error);
      else setTasks(data || []);
    }
    loadTasks();
  }, []);
  
  return <TaskList tasks={tasks} />;
}
```

### 2. Fetching Data (Server Component)
```typescript
import { createServerSupabaseClient } from '@/lib/supabase-server';

export default async function DashboardPage() {
  const supabase = await createServerSupabaseClient();
  const { data: tasks } = await supabase.from('tasks').select('*');
  
  return <TaskList tasks={tasks} />;
}
```

### 3. Form Handling
```typescript
// Client Component
'use client';
import { supabase } from '@/lib/supabase';
import { Button } from '@/components/ui';
import { toast } from 'sonner';

export function TaskForm() {
  const [formData, setFormData] = useState<TaskFormData>(initialState);
  
  async function handleSubmit(e: FormEvent) {
    e.preventDefault();
    const { error } = await supabase.from('tasks').insert(formData);
    if (error) {
      toast.error('Failed to create task');
      return;
    }
    toast.success('Task created');
  }
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

### 4. Protected Routes
```typescript
// Use AppContext for auth state
'use client';
import { useAppContext } from '@/context/AppContext';
import { useRouter } from 'next/navigation';

export default function ProtectedPage() {
  const { user, loading } = useAppContext();
  const router = useRouter();
  
  useEffect(() => {
    if (!loading && !user) {
      router.push('/login');
    }
  }, [user, loading, router]);
  
  if (loading) return <div>Loading...</div>;
  if (!user) return null;
  
  return <div>Protected content</div>;
}
```

## Domain-Specific Context

### Health & Safety Features
- Task management with deadlines and priorities
- Incident/accident reporting
- Temperature monitoring (fridge temps)
- Equipment maintenance tracking
- Staff training records
- Risk assessments

### Food Safety Specific
- HACCP compliance tracking
- Temperature logs (cooking, storage, display)
- Supplier verification
- Allergen management
- Cleaning schedules
- Waste/wastage reporting

### User Roles
- **Admin**: Full access, can manage all venues
- **Manager**: Venue-specific management
- **Staff**: Basic task completion and reporting

## When Providing Code Suggestions

### Always Include:
1. **Explanation**: Why you're suggesting this approach
2. **Full Context**: Don't just show snippets, show where it fits
3. **Error Handling**: Include try/catch and user feedback
4. **TypeScript Types**: Provide proper type definitions
5. **Comments**: Explain complex logic for novice developers

### Example of Good Response:
```typescript
// Create a new form for reporting temperature readings
// This goes in: components/dashboard/temperature-form.tsx

'use client'; // Needed because we use useState and form events

import { useState, FormEvent } from 'react';
import { supabase } from '@/lib/supabase';
import { Button } from '@/components/ui';
import { Input } from '@/components/ui/Input';
import { toast } from 'sonner';

interface TemperatureReading {
  equipment_id: string;
  temperature: number;
  recorded_at: Date;
}

export function TemperatureForm() {
  // State to track form inputs
  const [reading, setReading] = useState<TemperatureReading>({
    equipment_id: '',
    temperature: 0,
    recorded_at: new Date(),
  });
  
  // State to show loading during submission
  const [isLoading, setIsLoading] = useState(false);
  
  async function handleSubmit(e: FormEvent<HTMLFormElement>) {
    e.preventDefault(); // Prevent page reload
    setIsLoading(true);
    
    try {
      // Insert the reading into database
      const { error } = await supabase
        .from('temperature_readings')
        .insert(reading);
      
      if (error) throw error;
      
      // Success! Show message and reset form
      toast.success('Temperature recorded successfully');
      setReading({ equipment_id: '', temperature: 0, recorded_at: new Date() });
      
    } catch (error) {
      console.error('Error saving temperature:', error);
      toast.error('Failed to save temperature reading');
    } finally {
      setIsLoading(false);
    }
  }
  
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input
        type="number"
        placeholder="Temperature (°C)"
        value={reading.temperature}
        onChange={(e) => setReading({ ...reading, temperature: parseFloat(e.target.value) })}
        required
      />
      
      <Button type="submit" disabled={isLoading}>
        {isLoading ? 'Saving...' : 'Record Temperature'}
      </Button>
    </form>
  );
}
```

## Testing & Debugging Tips

### Common Issues & Solutions
1. **Hydration Errors**: Ensure server/client HTML matches - don't use random IDs or timestamps in Server Components. Use `suppressHydrationWarning` when necessary.
2. **Supabase Errors**: Always check `error` object and log it. Use `maybeSingle()` instead of `single()` when rows might not exist.
3. **TypeScript Errors**: Don't use `any` - define proper types. Types are in `/src/types` directory.
4. **Build Errors**: Run `npm run build` locally before deploying
5. **React Hooks Rules**: Always call hooks at the top level, before any conditional returns

### Debugging Checklist
- [ ] Check browser console for errors
- [ ] Verify Supabase connection in Network tab
- [ ] Confirm environment variables are set
- [ ] Check if you need 'use client' directive
- [ ] Verify user authentication status via AppContext
- [ ] Check for hydration mismatches in server/client HTML

## File Naming Conventions
- Components: `PascalCase.tsx` (e.g., `TaskCard.tsx`)
- Pages: `page.tsx` in kebab-case folders (e.g., `/dashboard/tasks/active/page.tsx`)
- Types: `PascalCase` for interfaces/types (e.g., `TaskFormData`)
- Functions: `camelCase`
- Constants: `UPPER_SNAKE_CASE`

## Import Paths
- Components: `@/components/ui` (barrel export) or `@/components/ui/Button`
- Supabase client: `@/lib/supabase` (client-side) or `@/lib/supabase-server` (server-side)
- Types: `@/types/supabase` or specific type files in `@/types`
- Context: `@/context/AppContext` or `@/context/SOPContext`
- Hooks: `@/hooks/useAttendance` etc.

## Git Commit Message Format
```
<type>: <short description>

<detailed description if needed>

Types: feat, fix, docs, style, refactor, test, chore
```

## Additional Notes for AI Assistants

When the developer asks for help:
1. **Ask clarifying questions** if the request is ambiguous
2. **Explain trade-offs** when multiple approaches exist
3. **Reference existing code** in the project when possible
4. **Provide runnable code** - complete, not just snippets
5. **Include next steps** - what to do after implementing your suggestion

Remember: This developer is a novice, so:
- Avoid jargon without explanation
- Show complete file paths
- Explain WHY, not just WHAT
- Provide context about where code should go
- Suggest how to test the changes
- Be careful not to break existing functionality when making changes
