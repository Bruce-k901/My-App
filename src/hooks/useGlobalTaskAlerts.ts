'use client';

import { useEffect, useRef, useCallback } from 'react';
import { supabase } from '@/lib/supabase';
import { useAlerts } from './useAlerts';
import { toast } from 'sonner';
import { TaskAlertToast } from '@/components/notifications/TaskAlertToast';
import { createElement } from 'react';

interface TaskSummary {
  id: string;
  status: string;
  due_date: string;
  due_time: string;
  custom_name: string | null;
  template_id: string | null;
  priority: string | null;
  daypart: string | null;
  assigned_to_role: string | null;
  task_data: { source?: string; [key: string]: unknown } | null;
}

interface TemplateLookup {
  name: string;
  category: string | null;
}

interface UseGlobalTaskAlertsOptions {
  companyId: string | null;
  siteId: string | null;
  userId: string | null;
  userRole?: string | null;
  enabled?: boolean;
  checkIntervalMs?: number;
}

export function useGlobalTaskAlerts({
  companyId,
  siteId,
  userId,
  userRole,
  enabled = true,
  checkIntervalMs = 60000,
}: UseGlobalTaskAlertsOptions) {
  const { alertTaskDue, alertUrgent, settings } = useAlerts();

  // In-memory state (useRef to avoid re-renders)
  const snoozeMap = useRef<Map<string, number>>(new Map()); // taskId -> expiry timestamp
  const dismissedIds = useRef<Set<string>>(new Set());
  const activeToastIds = useRef<Map<string, string | number>>(new Map()); // taskId -> sonner toast id
  const templateCache = useRef<Map<string, TemplateLookup>>(new Map());
  const lastFetchedTasks = useRef<TaskSummary[]>([]);

  const isTaskSnoozed = useCallback((taskId: string): boolean => {
    const expiresAt = snoozeMap.current.get(taskId);
    if (!expiresAt) return false;
    if (Date.now() >= expiresAt) {
      snoozeMap.current.delete(taskId);
      return false;
    }
    return true;
  }, []);

  const handleSnooze = useCallback((taskId: string, minutes: number) => {
    snoozeMap.current.set(taskId, Date.now() + minutes * 60 * 1000);
    activeToastIds.current.delete(taskId);
  }, []);

  const handleDismiss = useCallback((taskId: string) => {
    dismissedIds.current.add(taskId);
    activeToastIds.current.delete(taskId);
  }, []);

  const fetchTasks = useCallback(async (): Promise<TaskSummary[]> => {
    if (!companyId) return [];

    const now = new Date();
    const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

    let query = supabase
      .from('checklist_tasks')
      .select('id, status, due_date, due_time, custom_name, template_id, priority, daypart, assigned_to_role, assigned_to_user_id, task_data')
      .eq('company_id', companyId)
      .eq('due_date', today)
      .in('status', ['pending', 'in_progress'])
      .not('due_time', 'is', null);

    if (siteId && siteId !== 'all') {
      query = query.eq('site_id', siteId);
    }

    // Filter by role/user: admins and managers see everything,
    // other roles only see tasks assigned to their role, to them specifically, or unassigned
    const role = userRole?.toLowerCase();
    const isAdminOrManager = role === 'admin' || role === 'manager' || role === 'owner' || role === 'general_manager';
    if (!isAdminOrManager && role) {
      // Show tasks that are: assigned to this role, assigned to this user, or unassigned
      const filters = [`assigned_to_role.is.null,assigned_to_role.eq.${role}`];
      if (userId) {
        filters.push(`assigned_to_user_id.eq.${userId}`);
      }
      query = query.or(filters.join(','));
    }

    const { data, error } = await query;
    if (error) {
      console.debug('[TaskAlertSubscriber] Fetch error:', error.message);
      return [];
    }

    // Only notify for cron-generated instances or one-off tasks (no template).
    // Exclude seed/pattern tasks (have template_id but weren't generated by cron).
    return ((data || []) as TaskSummary[]).filter(
      (t) => t.task_data?.source === 'cron' || !t.template_id
    );
  }, [companyId, siteId, userId, userRole]);

  const resolveTemplateNames = useCallback(async (tasks: TaskSummary[]) => {
    const missingIds = tasks
      .filter((t) => t.template_id && !templateCache.current.has(t.template_id))
      .map((t) => t.template_id!)
      .filter((id, i, arr) => arr.indexOf(id) === i); // dedupe

    if (missingIds.length === 0) return;

    const { data } = await supabase
      .from('checklist_templates')
      .select('id, name, category')
      .in('id', missingIds);

    if (data) {
      data.forEach((t) => templateCache.current.set(t.id, { name: t.name, category: t.category }));
    }
  }, []);

  const getTaskName = useCallback((task: TaskSummary): string => {
    if (task.custom_name) return task.custom_name;
    if (task.template_id) return templateCache.current.get(task.template_id)?.name || 'Task';
    return 'Task';
  }, []);

  const getTaskCategory = useCallback((task: TaskSummary): string | null => {
    if (task.template_id) return templateCache.current.get(task.template_id)?.category || null;
    return null;
  }, []);

  // Check if current time falls within quiet hours
  const isInQuietHours = useCallback((): boolean => {
    try {
      const prefs = JSON.parse(localStorage.getItem('opsly_user_preferences') || '{}');
      const qh = prefs.quiet_hours;
      if (!qh?.enabled || !qh.start || !qh.end) return false;
      const now = new Date();
      const currentMinutes = now.getHours() * 60 + now.getMinutes();
      const [startH, startM] = qh.start.split(':').map(Number);
      const [endH, endM] = qh.end.split(':').map(Number);
      const startMinutes = startH * 60 + startM;
      const endMinutes = endH * 60 + endM;
      if (startMinutes > endMinutes) {
        return currentMinutes >= startMinutes || currentMinutes < endMinutes;
      }
      return currentMinutes >= startMinutes && currentMinutes < endMinutes;
    } catch { return false; }
  }, []);

  const checkAndAlert = useCallback(
    (tasks: TaskSummary[]) => {
      if (!settings.taskRemindersEnabled) return;
      // Suppress all alerts during quiet hours
      if (isInQuietHours()) return;

      const now = new Date();
      const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

      // Auto-dismiss toasts for tasks no longer in the list (completed/deleted)
      const currentIds = new Set(tasks.map((t) => t.id));
      activeToastIds.current.forEach((toastId, taskId) => {
        if (!currentIds.has(taskId)) {
          toast.dismiss(toastId);
          activeToastIds.current.delete(taskId);
        }
      });

      for (const task of tasks) {
        if (dismissedIds.current.has(task.id)) continue;
        if (isTaskSnoozed(task.id)) continue;
        if (activeToastIds.current.has(task.id)) continue;

        const dueDateTime = new Date(`${today}T${task.due_time}`);
        const timeSinceDue = now.getTime() - dueDateTime.getTime();

        // Only alert if due or overdue (within 2 min grace before due time)
        if (timeSinceDue < -120000) continue;

        const isOverdue = timeSinceDue > 0;
        const overdueMinutes = isOverdue ? Math.floor(timeSinceDue / 60000) : undefined;
        const taskName = getTaskName(task);
        const category = getTaskCategory(task);

        // Sound/vibration
        if (isOverdue && timeSinceDue > 15 * 60 * 1000) {
          alertUrgent();
        } else {
          alertTaskDue();
        }

        // Fire persistent custom toast
        const id = toast.custom(
          (toastId) =>
            createElement(TaskAlertToast, {
              toastId,
              taskId: task.id,
              taskName,
              dueTime: task.due_time,
              isOverdue,
              overdueMinutes,
              category,
              priority: task.priority,
              daypart: task.daypart,
              assignedToRole: task.assigned_to_role,
              onSnooze: handleSnooze,
              onDismiss: handleDismiss,
            }),
          { duration: Infinity }
        );

        activeToastIds.current.set(task.id, id);
      }
    },
    [settings.taskRemindersEnabled, isInQuietHours, isTaskSnoozed, getTaskName, getTaskCategory, alertTaskDue, alertUrgent, handleSnooze, handleDismiss]
  );

  // Main polling effect
  useEffect(() => {
    if (!enabled || !companyId || !settings.taskRemindersEnabled) return;

    let mounted = true;

    const runCheck = async () => {
      if (!mounted) return;
      const tasks = await fetchTasks();
      if (!mounted) return;
      await resolveTemplateNames(tasks);
      if (!mounted) return;
      lastFetchedTasks.current = tasks;
      checkAndAlert(tasks);
    };

    // Initial check after short delay to let app settle
    const initialTimeout = setTimeout(runCheck, 3000);

    // Interval for subsequent checks
    const interval = setInterval(runCheck, checkIntervalMs);

    return () => {
      mounted = false;
      clearTimeout(initialTimeout);
      clearInterval(interval);
    };
  }, [enabled, companyId, checkIntervalMs, settings.taskRemindersEnabled, fetchTasks, resolveTemplateNames, checkAndAlert]);

  // Reset at midnight
  useEffect(() => {
    const now = new Date();
    const midnight = new Date(now);
    midnight.setHours(24, 0, 0, 0);
    const msUntilMidnight = midnight.getTime() - now.getTime();

    const timeout = setTimeout(() => {
      snoozeMap.current.clear();
      dismissedIds.current.clear();
      activeToastIds.current.forEach((toastId) => toast.dismiss(toastId));
      activeToastIds.current.clear();
      templateCache.current.clear();
    }, msUntilMidnight);

    return () => clearTimeout(timeout);
  }, []);
}
